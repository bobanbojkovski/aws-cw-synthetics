const URL = require('url');
const synthetics = require('Synthetics');
const log = require('SyntheticsLogger');
const syntheticsConfiguration = synthetics.getConfiguration();
 
const loadBlueprint = async function () {
 
    let url_1 = process.env.url_1
    let url_2 = process.env.url_2
    const urls = [url_1, url_2];
 
    /* Disabling default step screen shots taken during Synthetics.executeStep() calls
    Step will be used to publish metrics on time taken to load dom content but
    Screenshots will be taken outside the executeStep to allow for page to completely load with domcontentloaded
    You can change it to load, networkidle0, networkidle2 depending on what works best for you.
    */
    syntheticsConfiguration.disableStepScreenshots();
    syntheticsConfiguration.setConfig({
       continueOnStepFailure: true,
       includeRequestHeaders: true, // Enable if headers should be displayed in HAR
       includeResponseHeaders: true, // Enable if headers should be displayed in HAR
       restrictedHeaders: [], // Value of these headers will be redacted from logs and reports
       restrictedUrlParameters: [] // Values of these url parameters will be redacted from logs and reports

    });
 
    /* Enable visual testing on a screenshot taken using the method takeScreenshot
    Screenshots taken in the current test run will be compared against screenshots taken in the base test run
    When a new canary is created, the first successful run will be chosen as the base test run
    A test run can be made a base run by passing it's baseTestRunId in the updateCanary API or using the Synthetics AWS console
    You can opt-in or opt-out a screenshot on which visual testing operation will be performed using the updateCanary API or the Synthetics AWS console
    */
    syntheticsConfiguration.withVisualCompareWithBaseRun(true);

 
    /* By default, when there is a difference between the base and current screenshot, the canary fails.
    You can configure the variance threshold percentage below which the canary won't fail using the withVisualVarianceThresholdPercentage method
    You can draw an area/boundary on the base screenshot which will be ignored during visual testing operation.
    You can draw ignore boundaries and export the coordinates to other clients like CloudFormation or SDK using the Synthetics AWS console. The boundary coordinates can also be exported us
    */
    syntheticsConfiguration.withVisualVarianceThresholdPercentage(0);
 
    let page = await synthetics.getPage();
 
    for (const url of urls) {
        await loadUrl(page, url);
    }
};
 
// Reset the page in-between
const resetPage = async function(page) {
    try {
        await page.goto('about:blank',{waitUntil: ['load', 'networkidle0'], timeout: 30000} );
    } catch(ex) {
        synthetics.addExecutionError('Unable to open a blank page ', ex);
    }
}
 
const loadUrl = async function (page, url) {
    let stepName = null;
    let domcontentloaded = false;
    try {
        stepName = URL.parse(url).hostname;
    } catch (error) {
        const errorString = `Error parsing url: ${url}.  ${error}`;
        log.error(errorString);
        /* If we fail to parse the URL, don't emit a metric with a stepName based on it.
           It may not be a legal CloudWatch metric dimension name and we may not have an alarms
           setup on the malformed URL stepName.  Instead, fail this step which will
           show up in the logs and will fail the overall canary and alarm on the overall canary
           success rate.
        */
        throw error;
    }
 
    await synthetics.executeStep(stepName, async function () {
 
        /* You can customize the wait condition here. For instance, using 'networkidle2' or 'networkidle0' to load page completely.
           networkidle0: Navigation is successful when the page has had no network requests for half a second. This might never happen if page is constantly loading multiple resources.
           networkidle2: Navigation is successful when the page has no more then 2 network requests for half a second.
           domcontentloaded: It's fired as soon as the page DOM has been loaded, without waiting for resources to finish loading. Can be used and then add explicit await page.waitFor(timeInMs)
        */
        const response = await page.goto(url, { waitUntil: ['domcontentloaded'], timeout: 30000});
        if (response) {
            domcontentloaded = true;
            const status = response.status();
            const statusText = response.statusText();
 
            const logResponseString = `Response from url: ${url}  Status: ${status}  Status Text: ${statusText}`;
 
            //If the response status code is not a 2xx success code
            if (response.status() < 200 || response.status() > 299) {
                throw `Failed to load url: ${url} ${response.status()} ${response.statusText()}`;
            }
        } else {
            const logNoResponseString = `No response returned for url: ${url}`;
            log.error(logNoResponseString);
            throw new Error(logNoResponseString);
        }
        // Wait for 3 seconds to let page load fully before taking the screenshot on which visual testing will be performed.
        await page.waitFor(3000);
        await synthetics.takeScreenshot(stepName, 'loaded');
    });
 
};
 
const urls = [];
 
exports.handler = async () => {
    return await loadBlueprint();
};